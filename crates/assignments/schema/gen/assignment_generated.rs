// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WORKER_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WORKER_STATUS: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WORKER_STATUS: [WorkerStatus; 4] = [
  WorkerStatus::Ok,
  WorkerStatus::Unreliable,
  WorkerStatus::DeprecatedVersion,
  WorkerStatus::UnsupportedVersion,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WorkerStatus(pub i8);
#[allow(non_upper_case_globals)]
impl WorkerStatus {
  pub const Ok: Self = Self(0);
  pub const Unreliable: Self = Self(1);
  pub const DeprecatedVersion: Self = Self(2);
  pub const UnsupportedVersion: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Ok,
    Self::Unreliable,
    Self::DeprecatedVersion,
    Self::UnsupportedVersion,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Ok => Some("Ok"),
      Self::Unreliable => Some("Unreliable"),
      Self::DeprecatedVersion => Some("DeprecatedVersion"),
      Self::UnsupportedVersion => Some("UnsupportedVersion"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for WorkerStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WorkerStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for WorkerStatus {
    type Output = WorkerStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WorkerStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WorkerStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WorkerStatus {}
// struct WorkerId, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct WorkerId(pub [u8; 38]);
impl Default for WorkerId { 
  fn default() -> Self { 
    Self([0; 38])
  }
}
impl core::fmt::Debug for WorkerId {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("WorkerId")
      .field("peer_id", &self.peer_id())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WorkerId {}
impl<'a> flatbuffers::Follow<'a> for WorkerId {
  type Inner = &'a WorkerId;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a WorkerId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a WorkerId {
  type Inner = &'a WorkerId;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<WorkerId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for WorkerId {
    type Output = WorkerId;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const WorkerId as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for WorkerId {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> WorkerId {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    peer_id: &[u8; 38],
  ) -> Self {
    let mut s = Self([0; 38]);
    s.set_peer_id(peer_id);
    s
  }

  pub fn peer_id(&'a self) -> flatbuffers::Array<'a, u8, 38> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_peer_id(&mut self, items: &[u8; 38]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

pub enum AssignmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Assignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Assignment<'a> {
  type Inner = Assignment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Assignment<'a> {
  pub const VT_DATASETS: flatbuffers::VOffsetT = 4;
  pub const VT_WORKERS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Assignment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AssignmentArgs<'args>
  ) -> flatbuffers::WIPOffset<Assignment<'bldr>> {
    let mut builder = AssignmentBuilder::new(_fbb);
    if let Some(x) = args.workers { builder.add_workers(x); }
    if let Some(x) = args.datasets { builder.add_datasets(x); }
    builder.finish()
  }


  #[inline]
  pub fn datasets(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dataset<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dataset>>>>(Assignment::VT_DATASETS, None).unwrap()}
  }
  #[inline]
  pub fn workers(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WorkerAssignment<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WorkerAssignment>>>>(Assignment::VT_WORKERS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Assignment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Dataset>>>>("datasets", Self::VT_DATASETS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WorkerAssignment>>>>("workers", Self::VT_WORKERS, true)?
     .finish();
    Ok(())
  }
}
pub struct AssignmentArgs<'a> {
    pub datasets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dataset<'a>>>>>,
    pub workers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WorkerAssignment<'a>>>>>,
}
impl<'a> Default for AssignmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    AssignmentArgs {
      datasets: None, // required field
      workers: None, // required field
    }
  }
}

pub struct AssignmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AssignmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_datasets(&mut self, datasets: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Dataset<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Assignment::VT_DATASETS, datasets);
  }
  #[inline]
  pub fn add_workers(&mut self, workers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WorkerAssignment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Assignment::VT_WORKERS, workers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AssignmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Assignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Assignment::VT_DATASETS,"datasets");
    self.fbb_.required(o, Assignment::VT_WORKERS,"workers");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Assignment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Assignment");
      ds.field("datasets", &self.datasets());
      ds.field("workers", &self.workers());
      ds.finish()
  }
}
pub enum WorkerAssignmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WorkerAssignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WorkerAssignment<'a> {
  type Inner = WorkerAssignment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WorkerAssignment<'a> {
  pub const VT_WORKER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS: flatbuffers::VOffsetT = 8;
  pub const VT_ENCRYPTED_HEADERS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WorkerAssignment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WorkerAssignmentArgs<'args>
  ) -> flatbuffers::WIPOffset<WorkerAssignment<'bldr>> {
    let mut builder = WorkerAssignmentBuilder::new(_fbb);
    if let Some(x) = args.encrypted_headers { builder.add_encrypted_headers(x); }
    if let Some(x) = args.chunks { builder.add_chunks(x); }
    if let Some(x) = args.worker_id { builder.add_worker_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn worker_id(&self) -> &'a WorkerId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WorkerId>(WorkerAssignment::VT_WORKER_ID, None).unwrap()}
  }
  #[inline]
  pub fn chunks(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk>>>>(WorkerAssignment::VT_CHUNKS, None).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> WorkerStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WorkerStatus>(WorkerAssignment::VT_STATUS, Some(WorkerStatus::Ok)).unwrap()}
  }
  #[inline]
  pub fn encrypted_headers(&self) -> Option<EncryptedHeaders<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EncryptedHeaders>>(WorkerAssignment::VT_ENCRYPTED_HEADERS, None)}
  }
}

impl flatbuffers::Verifiable for WorkerAssignment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<WorkerId>("worker_id", Self::VT_WORKER_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Chunk>>>>("chunks", Self::VT_CHUNKS, true)?
     .visit_field::<WorkerStatus>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EncryptedHeaders>>("encrypted_headers", Self::VT_ENCRYPTED_HEADERS, false)?
     .finish();
    Ok(())
  }
}
pub struct WorkerAssignmentArgs<'a> {
    pub worker_id: Option<&'a WorkerId>,
    pub chunks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>>>,
    pub status: WorkerStatus,
    pub encrypted_headers: Option<flatbuffers::WIPOffset<EncryptedHeaders<'a>>>,
}
impl<'a> Default for WorkerAssignmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    WorkerAssignmentArgs {
      worker_id: None, // required field
      chunks: None, // required field
      status: WorkerStatus::Ok,
      encrypted_headers: None,
    }
  }
}

pub struct WorkerAssignmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WorkerAssignmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_worker_id(&mut self, worker_id: &WorkerId) {
    self.fbb_.push_slot_always::<&WorkerId>(WorkerAssignment::VT_WORKER_ID, worker_id);
  }
  #[inline]
  pub fn add_chunks(&mut self, chunks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Chunk<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WorkerAssignment::VT_CHUNKS, chunks);
  }
  #[inline]
  pub fn add_status(&mut self, status: WorkerStatus) {
    self.fbb_.push_slot::<WorkerStatus>(WorkerAssignment::VT_STATUS, status, WorkerStatus::Ok);
  }
  #[inline]
  pub fn add_encrypted_headers(&mut self, encrypted_headers: flatbuffers::WIPOffset<EncryptedHeaders<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EncryptedHeaders>>(WorkerAssignment::VT_ENCRYPTED_HEADERS, encrypted_headers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WorkerAssignmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WorkerAssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WorkerAssignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, WorkerAssignment::VT_WORKER_ID,"worker_id");
    self.fbb_.required(o, WorkerAssignment::VT_CHUNKS,"chunks");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WorkerAssignment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WorkerAssignment");
      ds.field("worker_id", &self.worker_id());
      ds.field("chunks", &self.chunks());
      ds.field("status", &self.status());
      ds.field("encrypted_headers", &self.encrypted_headers());
      ds.finish()
  }
}
pub enum DatasetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dataset<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dataset<'a> {
  type Inner = Dataset<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Dataset<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_BLOCK: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dataset { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DatasetArgs<'args>
  ) -> flatbuffers::WIPOffset<Dataset<'bldr>> {
    let mut builder = DatasetBuilder::new(_fbb);
    builder.add_last_block(args.last_block);
    if let Some(x) = args.chunks { builder.add_chunks(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Dataset::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Dataset) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn chunks(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk>>>>(Dataset::VT_CHUNKS, None).unwrap()}
  }
  #[inline]
  pub fn last_block(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Dataset::VT_LAST_BLOCK, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Dataset<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Chunk>>>>("chunks", Self::VT_CHUNKS, true)?
     .visit_field::<u64>("last_block", Self::VT_LAST_BLOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct DatasetArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chunks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>>>,
    pub last_block: u64,
}
impl<'a> Default for DatasetArgs<'a> {
  #[inline]
  fn default() -> Self {
    DatasetArgs {
      id: None, // required field
      chunks: None, // required field
      last_block: 0,
    }
  }
}

pub struct DatasetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DatasetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dataset::VT_ID, id);
  }
  #[inline]
  pub fn add_chunks(&mut self, chunks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Chunk<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dataset::VT_CHUNKS, chunks);
  }
  #[inline]
  pub fn add_last_block(&mut self, last_block: u64) {
    self.fbb_.push_slot::<u64>(Dataset::VT_LAST_BLOCK, last_block, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DatasetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DatasetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dataset<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Dataset::VT_ID,"id");
    self.fbb_.required(o, Dataset::VT_CHUNKS,"chunks");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Dataset<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Dataset");
      ds.field("id", &self.id());
      ds.field("chunks", &self.chunks());
      ds.field("last_block", &self.last_block());
      ds.finish()
  }
}
pub enum ChunkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Chunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chunk<'a> {
  type Inner = Chunk<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Chunk<'a> {
  pub const VT_FIRST_BLOCK: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATASET_ID: flatbuffers::VOffsetT = 8;
  pub const VT_SIZE: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_BLOCK_HASH: flatbuffers::VOffsetT = 12;
  pub const VT_LAST_BLOCK_TIMESTAMP: flatbuffers::VOffsetT = 14;
  pub const VT_DATASET_BASE_URL: flatbuffers::VOffsetT = 16;
  pub const VT_BASE_URL: flatbuffers::VOffsetT = 18;
  pub const VT_FILES: flatbuffers::VOffsetT = 20;
  pub const VT_WORKER_INDEXES: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chunk { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ChunkArgs<'args>
  ) -> flatbuffers::WIPOffset<Chunk<'bldr>> {
    let mut builder = ChunkBuilder::new(_fbb);
    if let Some(x) = args.last_block_timestamp { builder.add_last_block_timestamp(x); }
    builder.add_first_block(args.first_block);
    if let Some(x) = args.worker_indexes { builder.add_worker_indexes(x); }
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.base_url { builder.add_base_url(x); }
    if let Some(x) = args.dataset_base_url { builder.add_dataset_base_url(x); }
    if let Some(x) = args.last_block_hash { builder.add_last_block_hash(x); }
    builder.add_size(args.size);
    if let Some(x) = args.dataset_id { builder.add_dataset_id(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn first_block(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Chunk::VT_FIRST_BLOCK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Chunk) -> bool {
    self.first_block() < o.first_block()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.first_block();
    key.cmp(&val)
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Chunk::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn dataset_id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Chunk::VT_DATASET_ID, None).unwrap()}
  }
  #[inline]
  pub fn size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Chunk::VT_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_block_hash(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Chunk::VT_LAST_BLOCK_HASH, None)}
  }
  #[inline]
  pub fn last_block_timestamp(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Chunk::VT_LAST_BLOCK_TIMESTAMP, None)}
  }
  #[inline]
  pub fn dataset_base_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Chunk::VT_DATASET_BASE_URL, None).unwrap()}
  }
  #[inline]
  pub fn base_url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Chunk::VT_BASE_URL, None).unwrap()}
  }
  #[inline]
  pub fn files(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileUrl<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileUrl>>>>(Chunk::VT_FILES, None).unwrap()}
  }
  #[inline]
  pub fn worker_indexes(&self) -> flatbuffers::Vector<'a, u16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Chunk::VT_WORKER_INDEXES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Chunk<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("first_block", Self::VT_FIRST_BLOCK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dataset_id", Self::VT_DATASET_ID, true)?
     .visit_field::<u32>("size", Self::VT_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("last_block_hash", Self::VT_LAST_BLOCK_HASH, false)?
     .visit_field::<u64>("last_block_timestamp", Self::VT_LAST_BLOCK_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dataset_base_url", Self::VT_DATASET_BASE_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("base_url", Self::VT_BASE_URL, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FileUrl>>>>("files", Self::VT_FILES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("worker_indexes", Self::VT_WORKER_INDEXES, true)?
     .finish();
    Ok(())
  }
}
pub struct ChunkArgs<'a> {
    pub first_block: u64,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dataset_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size: u32,
    pub last_block_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub last_block_timestamp: Option<u64>,
    pub dataset_base_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub base_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FileUrl<'a>>>>>,
    pub worker_indexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for ChunkArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChunkArgs {
      first_block: 0,
      id: None, // required field
      dataset_id: None, // required field
      size: 0,
      last_block_hash: None,
      last_block_timestamp: None,
      dataset_base_url: None, // required field
      base_url: None, // required field
      files: None, // required field
      worker_indexes: None, // required field
    }
  }
}

pub struct ChunkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChunkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_first_block(&mut self, first_block: u64) {
    self.fbb_.push_slot::<u64>(Chunk::VT_FIRST_BLOCK, first_block, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_ID, id);
  }
  #[inline]
  pub fn add_dataset_id(&mut self, dataset_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_DATASET_ID, dataset_id);
  }
  #[inline]
  pub fn add_size(&mut self, size: u32) {
    self.fbb_.push_slot::<u32>(Chunk::VT_SIZE, size, 0);
  }
  #[inline]
  pub fn add_last_block_hash(&mut self, last_block_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_LAST_BLOCK_HASH, last_block_hash);
  }
  #[inline]
  pub fn add_last_block_timestamp(&mut self, last_block_timestamp: u64) {
    self.fbb_.push_slot_always::<u64>(Chunk::VT_LAST_BLOCK_TIMESTAMP, last_block_timestamp);
  }
  #[inline]
  pub fn add_dataset_base_url(&mut self, dataset_base_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_DATASET_BASE_URL, dataset_base_url);
  }
  #[inline]
  pub fn add_base_url(&mut self, base_url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_BASE_URL, base_url);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FileUrl<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_FILES, files);
  }
  #[inline]
  pub fn add_worker_indexes(&mut self, worker_indexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Chunk::VT_WORKER_INDEXES, worker_indexes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ChunkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Chunk::VT_ID,"id");
    self.fbb_.required(o, Chunk::VT_DATASET_ID,"dataset_id");
    self.fbb_.required(o, Chunk::VT_DATASET_BASE_URL,"dataset_base_url");
    self.fbb_.required(o, Chunk::VT_BASE_URL,"base_url");
    self.fbb_.required(o, Chunk::VT_FILES,"files");
    self.fbb_.required(o, Chunk::VT_WORKER_INDEXES,"worker_indexes");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Chunk<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Chunk");
      ds.field("first_block", &self.first_block());
      ds.field("id", &self.id());
      ds.field("dataset_id", &self.dataset_id());
      ds.field("size", &self.size());
      ds.field("last_block_hash", &self.last_block_hash());
      ds.field("last_block_timestamp", &self.last_block_timestamp());
      ds.field("dataset_base_url", &self.dataset_base_url());
      ds.field("base_url", &self.base_url());
      ds.field("files", &self.files());
      ds.field("worker_indexes", &self.worker_indexes());
      ds.finish()
  }
}
pub enum FileUrlOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FileUrl<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileUrl<'a> {
  type Inner = FileUrl<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FileUrl<'a> {
  pub const VT_FILENAME: flatbuffers::VOffsetT = 4;
  pub const VT_URL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FileUrl { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FileUrlArgs<'args>
  ) -> flatbuffers::WIPOffset<FileUrl<'bldr>> {
    let mut builder = FileUrlBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.filename { builder.add_filename(x); }
    builder.finish()
  }


  #[inline]
  pub fn filename(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FileUrl::VT_FILENAME, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FileUrl::VT_URL, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for FileUrl<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filename", Self::VT_FILENAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct FileUrlArgs<'a> {
    pub filename: Option<flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FileUrlArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileUrlArgs {
      filename: None, // required field
      url: None, // required field
    }
  }
}

pub struct FileUrlBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FileUrlBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_filename(&mut self, filename: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileUrl::VT_FILENAME, filename);
  }
  #[inline]
  pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileUrl::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FileUrlBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FileUrlBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FileUrl<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FileUrl::VT_FILENAME,"filename");
    self.fbb_.required(o, FileUrl::VT_URL,"url");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FileUrl<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FileUrl");
      ds.field("filename", &self.filename());
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum EncryptedHeadersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EncryptedHeaders<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EncryptedHeaders<'a> {
  type Inner = EncryptedHeaders<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EncryptedHeaders<'a> {
  pub const VT_IDENTITY: flatbuffers::VOffsetT = 4;
  pub const VT_NONCE: flatbuffers::VOffsetT = 6;
  pub const VT_CIPHERTEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EncryptedHeaders { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EncryptedHeadersArgs<'args>
  ) -> flatbuffers::WIPOffset<EncryptedHeaders<'bldr>> {
    let mut builder = EncryptedHeadersBuilder::new(_fbb);
    if let Some(x) = args.ciphertext { builder.add_ciphertext(x); }
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    if let Some(x) = args.identity { builder.add_identity(x); }
    builder.finish()
  }


  #[inline]
  pub fn identity(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EncryptedHeaders::VT_IDENTITY, None).unwrap()}
  }
  #[inline]
  pub fn nonce(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EncryptedHeaders::VT_NONCE, None).unwrap()}
  }
  #[inline]
  pub fn ciphertext(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EncryptedHeaders::VT_CIPHERTEXT, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for EncryptedHeaders<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("identity", Self::VT_IDENTITY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("ciphertext", Self::VT_CIPHERTEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct EncryptedHeadersArgs<'a> {
    pub identity: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ciphertext: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for EncryptedHeadersArgs<'a> {
  #[inline]
  fn default() -> Self {
    EncryptedHeadersArgs {
      identity: None, // required field
      nonce: None, // required field
      ciphertext: None, // required field
    }
  }
}

pub struct EncryptedHeadersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EncryptedHeadersBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_identity(&mut self, identity: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EncryptedHeaders::VT_IDENTITY, identity);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EncryptedHeaders::VT_NONCE, nonce);
  }
  #[inline]
  pub fn add_ciphertext(&mut self, ciphertext: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EncryptedHeaders::VT_CIPHERTEXT, ciphertext);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EncryptedHeadersBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EncryptedHeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EncryptedHeaders<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EncryptedHeaders::VT_IDENTITY,"identity");
    self.fbb_.required(o, EncryptedHeaders::VT_NONCE,"nonce");
    self.fbb_.required(o, EncryptedHeaders::VT_CIPHERTEXT,"ciphertext");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EncryptedHeaders<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EncryptedHeaders");
      ds.field("identity", &self.identity());
      ds.field("nonce", &self.nonce());
      ds.field("ciphertext", &self.ciphertext());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Assignment`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_assignment_unchecked`.
pub fn root_as_assignment(buf: &[u8]) -> Result<Assignment, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Assignment>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Assignment` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_assignment_unchecked`.
pub fn size_prefixed_root_as_assignment(buf: &[u8]) -> Result<Assignment, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Assignment>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Assignment` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_assignment_unchecked`.
pub fn root_as_assignment_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Assignment<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Assignment<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Assignment` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_assignment_unchecked`.
pub fn size_prefixed_root_as_assignment_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Assignment<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Assignment<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Assignment and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Assignment`.
pub unsafe fn root_as_assignment_unchecked(buf: &[u8]) -> Assignment {
  flatbuffers::root_unchecked::<Assignment>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Assignment and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Assignment`.
pub unsafe fn size_prefixed_root_as_assignment_unchecked(buf: &[u8]) -> Assignment {
  flatbuffers::size_prefixed_root_unchecked::<Assignment>(buf)
}
#[inline]
pub fn finish_assignment_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Assignment<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_assignment_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Assignment<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
